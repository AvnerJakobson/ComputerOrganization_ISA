assembler run code:
asm.exe		 program.asm		imemin.txt      dmemin.txt
script_name	 asm_instructions	ins_mem_img		disk_mem_img
_________________________________________________________

assembler part in project file:

The Assembler
To be able to conveniently program the CPU and generate the initial memory images
in the files imemin.txt and dmemin.txt, we’ll also write an assembler. The assembler
will be written in the C programming language, and will program the assemble
program (written in text) into SIMP assembly language. It can be assumed that the
input file syntax is valid.
Similar to the simulator, the assembler is a command line application, with the
following run command line:

asm.exe program.asm imemin.txt dmemin.txt

The input file program.asm contains the assembly program, the output file
imemin.txt contains the initial instruction memory image, and the output file
dmemin.txt contains the initial data memory image. The output files of the assembler
are later used as input files for the simulator.
Each line of code in the assemble file contains all the 7 parameters in the encoding of
the instruction, where the first parameter is the opcode, and afterwards the parameters
are separated by comma. After the last parameters it is allowed to add the symbol #
and then add a comment on the right side, for example:
# opcode, rd, rs, rt, rm, imm1, imm2
add $t3, $t2, $t1, $t0, 0, 0 # $t3 = $t2 + $t1 + $t0
add $t1, $t1, $imm1, $zero, 2, 0 # $t1 = $t1 + 2
add $t1, $imm1, $imm1, $imm1, 2, 0 # $t1 = 2 + 2 + 2 = 6
sub $t1, $imm1, $imm2, $imm2, 2, 3 # $t1 = 2 – 3 – 3 = -4
In each instruction, there are 3 options for the immediate fields:
* A decimal number, positive or negative.
* A hexadecimal number that begins with 0x and then contains hexadecimal
digits.
* A label, which is a symbolic name starting with a letter and ending with :
Examples:
bne $zero, $t0, $t1, $imm1, L1, 0 # if ($t0 != $t1) goto L1
# (reg1 = address of L1)
add $t2, $t2, $imm1, $zero, 1, 0 # $t2 = $t2 + 1 (reg1 = 1)
beq $zero, $zero, $zero, $imm1, L2, 0 # jump to L2 (reg1 = address L2)
L1:
sub $t2, $t2, $imm1, $zero, 1, 0 # $t2 = $t2 – 1 (reg1 = 1)
L2:
add $t1, $zero, $imm1, $zero, L3, 0 # $t1 = address of L3
beq $zero, $zero, $zero, $t1, 0, 0 # jump to the address specified in t
L3:
jal $ra, $zero, $zero, $imm1, L4, 0 # function call L4, save return addr in
$ra
halt $zero, $zero, $zero, $zero, 0, 0 # halt execution
L4:
beq $zero, $zero, $zero, $ra, 0, 0 # return from function in address in $ra
To support labels, the assembler performs two passes on the code. In the first pass we
remember the addresses of all labels, and in the second pass in each place that was a
use of a label in the immediate field, we replace it with the actual address of the label
as calculated in the first pass.
Take note of the use of the special registers $imm1, $imm2 and $zero in the various
instructions. For example the beq instruction in the example jumps in case zero is
equal to zero. This condition is always true and therefore it is a method to implement
unconditional jump.
In addition to the instructions of the code, the assembler supports a pseudo-instruction
that allows to set the contents of a 32-bit data word directly in the initial data memory
image:
.word address data
Where address is the address of the word and data its value. Each one of the fields can
be in decimal, or hexadecimal when preceded with 0x, for example:
.word 256 1 # set MEM[256] = 1
.word 0x100 0x1234ABCD # MEM[0x100] = MEM[256] = 0x1234ABCD

output struct:
X	X	X	X	X	X	X	X	X	X	X	X
op	op	rd	rs	rt	rm	im1	im1	im1	im2	im2	im2

op mapping:
add	0	00		lw		16	10
sub	1	01		sw		17	11
mac	2	02		reti	18	12
and	3	03		in		19	13
or	4	04		out		20	14
xor	5	05		halt	21	15
sll	6	06
sra	7	07
srl	8	08
beq	9	09
bne	10	0A
blt	11	0B
bgt	12	0C
ble	13	0D
bge	14	0E
jal	15	0F

Register mappings:
0	$zero	Constant zero
1	$imm1	Sign extended immediate 1
2	$imm2	Sign extended immediate 2
3	$v0		Result value
4	$a0		Argument register
5	$a1		Argument register
6	$a2		Argument register
7	$t0		Temporary register
8	$t1		Temporary register
9	$t2		Temporary register
A	$s0		Saved register
B	$s1		Saved register
C	$s2		Saved register
D	$gp		Global pointer (static data)
E	$sp		Stack pointer
F	$ra		Return address
 
	